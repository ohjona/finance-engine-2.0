# Finance Engine v2.0: Phasing Plan + Phase 1 Implementation Prompt

**Author:** Chief Architect (Claude Opus 4.5)
**Date:** 2026-01-31
**Status:** Ready for Implementation

---

# Part 1: Phasing Plan

## Phase Overview

| Phase | Name | Packages | Est. Production LOC | Est. Test LOC | Dependencies |
|-------|------|----------|---------------------|---------------|--------------|
| 1 | Foundation + Proof of Architecture | shared, core, cli, web | ~450 | ~300 | None |
| 2 | Complete Parser Module | core, shared | ~500 | ~600 | Phase 1 |
| 3 | Categorizer Module | core, shared | ~500 | ~500 | Phase 2 |
| 4 | Matcher + Ledger Modules | core, shared | ~500 | ~400 | Phase 3 |
| 5 | CLI Implementation | cli, shared | ~900 | ~600 | Phase 4 |
| **Total** | | | **~2850** | **~2400** | |

---

## Phase 1: Foundation + Proof of Architecture

**Scope:** Establish complete monorepo infrastructure with build tooling, shared types package, and a minimal working parser to prove the headless core architecture works end-to-end.

**Packages:** `shared` (primary), `core` (skeleton + one parser), `cli` (minimal PoC), `web` (scaffold only)

**Components:**
- Monorepo infrastructure (pnpm workspaces, TypeScript project references, Vitest, ESLint/Prettier)
- `@finance-engine/shared`: Zod schemas for Transaction, Rule, RuleSet, Account, ChartOfAccounts
- `@finance-engine/core`: generateTxnId(), resolveCollisions(), normalizeDescription(), parseAmex()
- `@finance-engine/cli`: Minimal proof reading one file and calling core parser
- `@finance-engine/web`: Empty scaffold

**Entry Criteria:**
- Clean git repository with documentation

**Exit Criteria:**
- `pnpm install` succeeds
- `pnpm build` compiles all packages
- `pnpm test` passes
- CLI can parse a sample Amex file
- Core package has zero `node:fs` imports (architecture constraint verified)

**Key Risks:**
- decimal.js/Zod integration (mitigate: store as strings)
- TypeScript project references configuration

**Estimated Size:** ~450 production, ~300 test, ~200 config

---

## Phase 2: Complete Parser Module

**Scope:** Implement all six bank parsers with full test coverage.

**Packages:** `core` (parser module), `shared` (refinements)

**Components:**
- parseAmex() refinement
- parseChaseChecking() - CSV, MM/DD/YYYY dates
- parseBoaChecking() - CSV with smart header detection
- parseBoaCredit() - CSV
- parseFidelity() - CSV, YYYY-MM-DD dates
- parseDiscover() - XLS (HTML table)
- detectParser() filename matching
- extractAccountId() from filename
- Sign normalization per source

**Entry Criteria:**
- Phase 1 complete
- Sample fixture files for each bank (anonymized)

**Exit Criteria:**
- All 6 parsers implemented and tested
- Edge cases handled (empty files, missing columns, invalid dates)
- Test coverage >90% on parser module

**Key Risks:**
- Discover XLS format (HTML table parsing)
- Bank format variations

**Estimated Size:** ~500 production, ~600 test

---

## Phase 3: Categorizer Module

**Scope:** Implement 4-layer categorization system with pattern matching.

**Packages:** `core` (categorizer), `shared` (refinements)

**Components:**
- categorize() with 4-layer priority
- matchesPattern() - substring and regex
- guessFromBankCategory() mapping
- Rule mutation helpers (pure functions)
- Pattern validation (breadth, collision detection)

**Entry Criteria:**
- Phase 2 complete
- Sample rules files

**Exit Criteria:**
- 4-layer hierarchy works correctly
- Confidence scores assigned per layer
- Invalid regex handled gracefully
- Pattern validation prevents overly broad patterns

**Key Risks:**
- Rule ordering sensitivity
- Regex edge cases

**Estimated Size:** ~500 production, ~500 test

---

## Phase 4: Matcher + Ledger Modules

**Scope:** Implement payment matching and double-entry journal generation.

**Packages:** `core` (matcher, ledger), `shared` (JournalEntry, Match schemas)

**Components:**
- matchPayments() with date/amount tolerance
- findBestMatch() algorithm
- generateJournal() for all transaction types
- validateJournal() debits = credits
- Refund handling (credit original expense)
- Payment keyword requirement

**Entry Criteria:**
- Phase 3 complete

**Exit Criteria:**
- Payment matching within tolerances
- Ambiguous matches flagged, not auto-resolved
- Journal entries balance
- All PRD Appendix C double-entry patterns implemented

**Key Risks:**
- Same-day multiple payments
- Refund vs reward distinction

**Estimated Size:** ~500 production, ~400 test

---

## Phase 5: CLI Implementation

**Scope:** Complete CLI with file I/O, Excel output, workspace management, process and add-rule commands.

**Packages:** `cli` (primary), `shared` (ManifestSchema)

**Components:**
- Workspace auto-detection
- Config loading (YAML/JSON)
- process command (10-step pipeline)
- add-rule command
- Excel output (journal.xlsx, review.xlsx, analysis.xlsx)
- Run manifest
- Input archiving
- Error handling with prompts

**Entry Criteria:**
- Phases 1-4 complete

**Exit Criteria:**
- `npx fineng process YYYY-MM` works end-to-end
- `npx fineng add-rule PATTERN CATEGORY` works
- All flags: --dry-run, --force, --yes
- Excel outputs match PRD specs

**Key Risks:**
- YAML round-trip preservation
- Cross-platform paths
- TTY detection

**Estimated Size:** ~900 production, ~600 test

---

# Part 2: Phase 1 Implementation Prompt

## Overview

Phase 1 establishes the complete monorepo foundation and proves the headless core architecture with a working end-to-end example: parsing one Amex file.

**When complete, Antigravity will have:**
1. A buildable, testable pnpm monorepo with 4 packages
2. Complete Zod schemas for core data types
3. Working `generateTxnId()`, `resolveCollisions()`, `normalizeDescription()`
4. Working `parseAmex()` parser
5. CLI proof-of-concept that reads a file and calls the core parser
6. Verified architecture constraint: core has no I/O imports

---

## Pre-Implementation Setup

### Task 0.1: Initialize Repository

**Branch:** `phase-1/foundation`

```bash
cd /Users/jonathanoh/Dev/finance-engine-2.0
git checkout -b phase-1/foundation
```

### Task 0.2: Create Root package.json

**File:** `package.json` — CREATE

```json
{
  "name": "finance-engine",
  "version": "2.0.0",
  "private": true,
  "type": "module",
  "packageManager": "pnpm@9.0.0",
  "scripts": {
    "build": "pnpm -r build",
    "test": "pnpm -r test",
    "lint": "eslint packages/*/src/**/*.ts",
    "format": "prettier --write \"packages/*/src/**/*.ts\"",
    "clean": "pnpm -r exec rm -rf dist",
    "typecheck": "pnpm -r typecheck"
  },
  "devDependencies": {
    "@types/node": "^20.10.0",
    "eslint": "^8.55.0",
    "@typescript-eslint/eslint-plugin": "^6.13.0",
    "@typescript-eslint/parser": "^6.13.0",
    "prettier": "^3.1.0",
    "typescript": "^5.3.0",
    "vitest": "^1.0.0"
  }
}
```

### Task 0.3: Create pnpm-workspace.yaml

**File:** `pnpm-workspace.yaml` — CREATE

```yaml
packages:
  - 'packages/*'
```

### Task 0.4: Create Root TypeScript Config

**File:** `tsconfig.json` — CREATE

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "lib": ["ES2022"],
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "declaration": true,
    "declarationMap": true,
    "composite": true,
    "noEmit": false,
    "outDir": "dist",
    "rootDir": "src"
  }
}
```

### Task 0.5: Create Vitest Config

**File:** `vitest.config.ts` — CREATE

```typescript
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    include: ['packages/*/tests/**/*.test.ts'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'html'],
      include: ['packages/*/src/**/*.ts'],
    },
  },
});
```

### Task 0.6: Create ESLint Config

**File:** `eslint.config.js` — CREATE

```javascript
import eslint from '@eslint/js';
import tseslint from '@typescript-eslint/eslint-plugin';
import tsparser from '@typescript-eslint/parser';

export default [
  eslint.configs.recommended,
  {
    files: ['packages/*/src/**/*.ts'],
    languageOptions: {
      parser: tsparser,
      parserOptions: {
        ecmaVersion: 2022,
        sourceType: 'module',
      },
    },
    plugins: {
      '@typescript-eslint': tseslint,
    },
    rules: {
      '@typescript-eslint/no-unused-vars': ['error', { argsIgnorePattern: '^_' }],
      '@typescript-eslint/explicit-function-return-type': 'off',
      'no-console': 'warn',
    },
  },
];
```

### Task 0.7: Create Prettier Config

**File:** `.prettierrc` — CREATE

```json
{
  "semi": true,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "es5",
  "printWidth": 100
}
```

### Task 0.8: Update .gitignore

**File:** `.gitignore` — REPLACE

```
# Dependencies
node_modules/

# Build outputs
dist/
*.tsbuildinfo

# OS files
.DS_Store
Thumbs.db

# IDE
.idea/
.vscode/
*.swp
*.swo

# Environment
.env
.env.local

# Coverage
coverage/

# Logs
*.log
npm-debug.log*

# Temp files
~$*
```

---

## Package Setup

### Task 1.1: Create @finance-engine/shared Package

**Directory structure:**
```
packages/shared/
├── package.json
├── tsconfig.json
├── src/
│   ├── index.ts
│   ├── schemas.ts
│   └── constants.ts
└── tests/
    └── schemas.test.ts
```

**File:** `packages/shared/package.json` — CREATE

```json
{
  "name": "@finance-engine/shared",
  "version": "2.0.0",
  "type": "module",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "import": "./dist/index.js",
      "types": "./dist/index.d.ts"
    }
  },
  "scripts": {
    "build": "tsc",
    "test": "vitest run",
    "typecheck": "tsc --noEmit"
  },
  "dependencies": {
    "zod": "^3.22.0"
  }
}
```

**File:** `packages/shared/tsconfig.json` — CREATE

```json
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*.ts"],
  "exclude": ["tests", "dist"]
}
```

**File:** `packages/shared/src/constants.ts` — CREATE

Per IK D2.7 and D4.2, define confidence constants:

```typescript
/**
 * Category ID for uncategorized transactions.
 * Visually distinct from 4990 (Miscellaneous) to indicate categorization failure.
 * Per IK D2.7.
 */
export const UNCATEGORIZED_CATEGORY_ID = 4999;

/**
 * Confidence scores per categorization source.
 * Per IK D4.2.
 */
export const CONFIDENCE = {
  USER_RULES: 1.0,
  SHARED_RULES: 0.9,
  LLM_APPROVED: 0.85,
  BASE_RULES: 0.8,
  LLM_INFERENCE: 0.7,
  BANK_CATEGORY: 0.6,
  UNCATEGORIZED: 0.3,
} as const;

/**
 * Pattern matching configuration.
 * Per IK D4.7, D4.8.
 */
export const PATTERN_VALIDATION = {
  MIN_LENGTH: 5,
  MAX_MATCH_PERCENT: 0.2,
  MAX_MATCHES_FOR_BROAD: 3,
} as const;

/**
 * Payment matching configuration.
 * Per IK D6.1, D6.2.
 */
export const MATCHING_CONFIG = {
  DATE_TOLERANCE_DAYS: 5,
  AMOUNT_TOLERANCE: '0.01',
} as const;
```

**File:** `packages/shared/src/schemas.ts` — CREATE

Per PRD Section 7, implement Zod schemas. Note: Decimal values are stored as strings in schemas and converted at boundaries (per IK D2.2).

```typescript
import { z } from 'zod';

/**
 * ISO date string format: YYYY-MM-DD
 */
const isoDateString = z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Must be YYYY-MM-DD format');

/**
 * Decimal amount as string (never native number for money).
 * Per IK D2.2.
 */
const decimalString = z.string().regex(/^-?\d+(\.\d+)?$/, 'Must be valid decimal string');

/**
 * 4-digit account ID (1000-9999).
 * Per IK D2.11.
 */
const accountId = z.number().int().min(1000).max(9999);

/**
 * 16-character transaction ID (SHA-256 truncated).
 * Per IK D2.3.
 */
const txnId = z.string().length(16);

/**
 * Transaction schema - the normalized form all bank exports become.
 * Per PRD Section 7.1.
 */
export const TransactionSchema = z.object({
  txn_id: txnId,
  txn_date: isoDateString,
  post_date: isoDateString,
  effective_date: isoDateString,
  description: z.string(),
  raw_description: z.string(),
  signed_amount: decimalString,
  account_id: accountId,
  category_id: z.number().int(),
  raw_category: z.string().optional(),
  source_file: z.string(),
  confidence: z.number().min(0).max(1),
  needs_review: z.boolean(),
  review_reasons: z.array(z.string()),
});

export type Transaction = z.infer<typeof TransactionSchema>;

/**
 * Categorization result - what categorize() returns.
 * Per PRD Section 9.2.
 */
export const CategorizationResultSchema = z.object({
  category_id: z.number().int(),
  confidence: z.number().min(0).max(1),
  source: z.enum(['user', 'shared', 'base', 'bank', 'uncategorized']),
  needs_review: z.boolean(),
  review_reasons: z.array(z.string()),
});

export type CategorizationResult = z.infer<typeof CategorizationResultSchema>;

/**
 * Rule schema for categorization patterns.
 * Per IK D2.10.
 */
export const RuleSchema = z.object({
  pattern: z.string().min(1),
  pattern_type: z.enum(['substring', 'regex']).default('substring'),
  category_id: z.number().int(),
  note: z.string().optional(),
  added_date: isoDateString.optional(),
  source: z.enum(['manual', 'llm_suggestion']).optional(),
});

export type Rule = z.infer<typeof RuleSchema>;

/**
 * RuleSet containing all rule layers.
 * Per IK D4.1 - 4-layer model.
 */
export const RuleSetSchema = z.object({
  user_rules: z.array(RuleSchema),
  shared_rules: z.array(RuleSchema),
  base_rules: z.array(RuleSchema),
});

export type RuleSet = z.infer<typeof RuleSetSchema>;

/**
 * Account definition.
 * Per PRD Section 7.3.
 */
export const AccountSchema = z.object({
  name: z.string(),
  type: z.enum(['asset', 'liability', 'income', 'expense', 'special']),
  institution: z.string().optional(),
  parent: z.string().optional(),
});

export type Account = z.infer<typeof AccountSchema>;

/**
 * Chart of accounts map.
 */
export const ChartOfAccountsSchema = z.object({
  accounts: z.record(z.string(), AccountSchema),
});

export type ChartOfAccounts = z.infer<typeof ChartOfAccountsSchema>;

/**
 * Journal entry line.
 * Per PRD Section 7.2.
 */
export const JournalLineSchema = z.object({
  account_id: accountId,
  account_name: z.string(),
  debit: decimalString.nullable(),
  credit: decimalString.nullable(),
  txn_id: txnId,
});

export type JournalLine = z.infer<typeof JournalLineSchema>;

/**
 * Complete journal entry with lines.
 * Per PRD Section 7.2.
 */
export const JournalEntrySchema = z.object({
  entry_id: z.number().int(),
  date: isoDateString,
  description: z.string(),
  lines: z.array(JournalLineSchema),
});

export type JournalEntry = z.infer<typeof JournalEntrySchema>;

/**
 * Run manifest for tracking processed files.
 * Per IK D8.2.
 */
export const RunManifestSchema = z.object({
  month: z.string().regex(/^\d{4}-\d{2}$/, 'Must be YYYY-MM format'),
  run_timestamp: z.string(),
  input_files: z.record(z.string(), z.string()),
  transaction_count: z.number().int().min(0),
  txn_ids: z.array(z.string()),
  collision_map: z.record(z.string(), z.number().int()),
  version: z.string(),
});

export type RunManifest = z.infer<typeof RunManifestSchema>;
```

**File:** `packages/shared/src/index.ts` — CREATE

```typescript
// Schemas
export {
  TransactionSchema,
  CategorizationResultSchema,
  RuleSchema,
  RuleSetSchema,
  AccountSchema,
  ChartOfAccountsSchema,
  JournalLineSchema,
  JournalEntrySchema,
  RunManifestSchema,
} from './schemas.js';

// Types
export type {
  Transaction,
  CategorizationResult,
  Rule,
  RuleSet,
  Account,
  ChartOfAccounts,
  JournalLine,
  JournalEntry,
  RunManifest,
} from './schemas.js';

// Constants
export {
  UNCATEGORIZED_CATEGORY_ID,
  CONFIDENCE,
  PATTERN_VALIDATION,
  MATCHING_CONFIG,
} from './constants.js';
```

**File:** `packages/shared/tests/schemas.test.ts` — CREATE

```typescript
import { describe, it, expect } from 'vitest';
import {
  TransactionSchema,
  RuleSchema,
  RuleSetSchema,
  AccountSchema,
  ChartOfAccountsSchema,
} from '../src/schemas.js';

describe('TransactionSchema', () => {
  it('validates a complete transaction', () => {
    const valid = {
      txn_id: 'a1b2c3d4e5f67890',
      txn_date: '2026-01-15',
      post_date: '2026-01-16',
      effective_date: '2026-01-15',
      description: 'UBER TRIP',
      raw_description: 'UBER *TRIP HELP.UBER.COM',
      signed_amount: '-23.45',
      account_id: 2122,
      category_id: 4260,
      raw_category: 'Transportation-Taxi',
      source_file: 'amex_2122_202601.xlsx',
      confidence: 0.95,
      needs_review: false,
      review_reasons: [],
    };

    const result = TransactionSchema.safeParse(valid);
    expect(result.success).toBe(true);
  });

  it('rejects invalid txn_id length', () => {
    const invalid = {
      txn_id: 'tooshort',
      txn_date: '2026-01-15',
      post_date: '2026-01-16',
      effective_date: '2026-01-15',
      description: 'TEST',
      raw_description: 'TEST',
      signed_amount: '-10.00',
      account_id: 2122,
      category_id: 4260,
      source_file: 'test.xlsx',
      confidence: 0.95,
      needs_review: false,
      review_reasons: [],
    };

    const result = TransactionSchema.safeParse(invalid);
    expect(result.success).toBe(false);
  });

  it('rejects invalid date format', () => {
    const invalid = {
      txn_id: 'a1b2c3d4e5f67890',
      txn_date: '01/15/2026', // Wrong format
      post_date: '2026-01-16',
      effective_date: '2026-01-15',
      description: 'TEST',
      raw_description: 'TEST',
      signed_amount: '-10.00',
      account_id: 2122,
      category_id: 4260,
      source_file: 'test.xlsx',
      confidence: 0.95,
      needs_review: false,
      review_reasons: [],
    };

    const result = TransactionSchema.safeParse(invalid);
    expect(result.success).toBe(false);
  });

  it('rejects account_id outside valid range', () => {
    const invalid = {
      txn_id: 'a1b2c3d4e5f67890',
      txn_date: '2026-01-15',
      post_date: '2026-01-16',
      effective_date: '2026-01-15',
      description: 'TEST',
      raw_description: 'TEST',
      signed_amount: '-10.00',
      account_id: 999, // Too low
      category_id: 4260,
      source_file: 'test.xlsx',
      confidence: 0.95,
      needs_review: false,
      review_reasons: [],
    };

    const result = TransactionSchema.safeParse(invalid);
    expect(result.success).toBe(false);
  });
});

describe('RuleSchema', () => {
  it('validates a basic rule', () => {
    const valid = {
      pattern: 'UBER',
      category_id: 4260,
    };

    const result = RuleSchema.safeParse(valid);
    expect(result.success).toBe(true);
    if (result.success) {
      expect(result.data.pattern_type).toBe('substring'); // Default
    }
  });

  it('validates a rule with all fields', () => {
    const valid = {
      pattern: 'WARBY PARKER',
      pattern_type: 'substring' as const,
      category_id: 4550,
      note: 'Vision/eyewear',
      added_date: '2026-01-18',
      source: 'manual' as const,
    };

    const result = RuleSchema.safeParse(valid);
    expect(result.success).toBe(true);
  });

  it('rejects empty pattern', () => {
    const invalid = {
      pattern: '',
      category_id: 4260,
    };

    const result = RuleSchema.safeParse(invalid);
    expect(result.success).toBe(false);
  });
});

describe('RuleSetSchema', () => {
  it('validates a complete ruleset', () => {
    const valid = {
      user_rules: [{ pattern: 'WARBY', category_id: 4550 }],
      shared_rules: [{ pattern: 'NETFLIX', category_id: 4610 }],
      base_rules: [{ pattern: 'UBER', category_id: 4260 }],
    };

    const result = RuleSetSchema.safeParse(valid);
    expect(result.success).toBe(true);
  });

  it('validates empty ruleset', () => {
    const valid = {
      user_rules: [],
      shared_rules: [],
      base_rules: [],
    };

    const result = RuleSetSchema.safeParse(valid);
    expect(result.success).toBe(true);
  });
});

describe('AccountSchema', () => {
  it('validates an asset account', () => {
    const valid = {
      name: 'Chase Checking 6917',
      type: 'asset' as const,
      institution: 'Chase',
    };

    const result = AccountSchema.safeParse(valid);
    expect(result.success).toBe(true);
  });

  it('validates an expense account with parent', () => {
    const valid = {
      name: 'Rideshare (Uber/Lyft)',
      type: 'expense' as const,
      parent: '4200 - Transportation',
    };

    const result = AccountSchema.safeParse(valid);
    expect(result.success).toBe(true);
  });
});

describe('ChartOfAccountsSchema', () => {
  it('validates a chart of accounts', () => {
    const valid = {
      accounts: {
        '1120': {
          name: 'Chase Checking 6917',
          type: 'asset' as const,
          institution: 'Chase',
        },
        '2122': {
          name: 'Amex Delta Sky Reserve',
          type: 'liability' as const,
          institution: 'Amex',
        },
        '4260': {
          name: 'Rideshare (Uber/Lyft)',
          type: 'expense' as const,
          parent: '4200 - Transportation',
        },
      },
    };

    const result = ChartOfAccountsSchema.safeParse(valid);
    expect(result.success).toBe(true);
  });
});
```

### Task 1.2: Create @finance-engine/core Package

**Directory structure:**
```
packages/core/
├── package.json
├── tsconfig.json
├── src/
│   ├── index.ts
│   ├── types/
│   │   └── index.ts
│   ├── utils/
│   │   ├── index.ts
│   │   ├── txn-id.ts
│   │   └── normalize.ts
│   └── parser/
│       ├── index.ts
│       ├── amex.ts
│       └── detect.ts
└── tests/
    ├── utils/
    │   ├── txn-id.test.ts
    │   └── normalize.test.ts
    └── parser/
        └── amex.test.ts
```

**File:** `packages/core/package.json` — CREATE

```json
{
  "name": "@finance-engine/core",
  "version": "2.0.0",
  "type": "module",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "import": "./dist/index.js",
      "types": "./dist/index.d.ts"
    }
  },
  "scripts": {
    "build": "tsc",
    "test": "vitest run",
    "typecheck": "tsc --noEmit"
  },
  "dependencies": {
    "@finance-engine/shared": "workspace:*",
    "decimal.js": "^10.4.0",
    "xlsx": "^0.18.0"
  }
}
```

**File:** `packages/core/tsconfig.json` — CREATE

```json
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*.ts"],
  "exclude": ["tests", "dist"],
  "references": [
    { "path": "../shared" }
  ]
}
```

**File:** `packages/core/src/types/index.ts` — CREATE

```typescript
/**
 * Re-export all types from shared package.
 * Core package uses these types but doesn't define them.
 */
export type {
  Transaction,
  CategorizationResult,
  Rule,
  RuleSet,
  Account,
  ChartOfAccounts,
  JournalLine,
  JournalEntry,
  RunManifest,
} from '@finance-engine/shared';

export {
  TransactionSchema,
  CategorizationResultSchema,
  RuleSchema,
  RuleSetSchema,
  AccountSchema,
  ChartOfAccountsSchema,
  JournalLineSchema,
  JournalEntrySchema,
  RunManifestSchema,
  UNCATEGORIZED_CATEGORY_ID,
  CONFIDENCE,
  PATTERN_VALIDATION,
  MATCHING_CONFIG,
} from '@finance-engine/shared';
```

**File:** `packages/core/src/utils/txn-id.ts` — CREATE

Per PRD Section 7.5 and IK D2.3, D2.4, D2.12:

```typescript
import { createHash } from 'crypto';
import Decimal from 'decimal.js';
import type { Transaction } from '../types/index.js';

/**
 * Generate deterministic transaction ID via SHA-256 hash.
 *
 * Payload format: "{effective_date}|{raw_description}|{signed_amount}|{account_id}"
 *
 * Per IK D2.3: 16-character hex string, filename-independent.
 * Per IK D2.12:
 *   - effective_date: ISO 8601 YYYY-MM-DD
 *   - raw_description: raw bytes (NO normalization before hash)
 *   - signed_amount: plain decimal string, no trailing zeros
 *   - account_id: integer as string
 */
export function generateTxnId(
  effectiveDate: string,
  rawDescription: string,
  signedAmount: Decimal,
  accountId: number
): string {
  // Normalize amount to plain decimal string (no trailing zeros, no exponent)
  const amountStr = signedAmount.toFixed();

  const payload = `${effectiveDate}|${rawDescription}|${amountStr}|${accountId}`;
  return createHash('sha256').update(payload).digest('hex').slice(0, 16);
}

/**
 * Resolve collisions by adding deterministic suffixes.
 *
 * Per IK D2.4: Same-day duplicate transactions get -02, -03, etc.
 * Per IK D2.13: Files must be processed in lexicographic sort order for determinism.
 *
 * Mutates transactions in place by appending suffixes to txn_id.
 */
export function resolveCollisions(transactions: Transaction[]): void {
  const seen: Record<string, number> = {};

  for (const txn of transactions) {
    const baseId = txn.txn_id;

    if (seen[baseId]) {
      seen[baseId] += 1;
      // Suffix format: -02, -03, etc.
      txn.txn_id = `${baseId}-${String(seen[baseId]).padStart(2, '0')}`;
    } else {
      seen[baseId] = 1;
    }
  }
}

/**
 * Build collision map for run manifest.
 * Returns map of base ID -> count for IDs with collisions.
 */
export function buildCollisionMap(transactions: Transaction[]): Record<string, number> {
  const counts: Record<string, number> = {};

  for (const txn of transactions) {
    // Extract base ID (remove suffix if present)
    const baseId = txn.txn_id.includes('-')
      ? txn.txn_id.split('-')[0]
      : txn.txn_id;

    counts[baseId] = (counts[baseId] || 0) + 1;
  }

  // Only return entries with collisions (count > 1)
  const collisionMap: Record<string, number> = {};
  for (const [id, count] of Object.entries(counts)) {
    if (count > 1) {
      collisionMap[id] = count;
    }
  }

  return collisionMap;
}
```

**File:** `packages/core/src/utils/normalize.ts` — CREATE

Per PRD Section 9.3 and IK D3.8:

```typescript
/**
 * Normalize transaction description for consistent pattern matching.
 *
 * Per PRD Section 9.3:
 * - Uppercase
 * - Replace * and # with space
 * - Collapse whitespace
 * - Trim
 *
 * Note: This is for matching, NOT for txn_id generation.
 * txn_id uses raw_description per IK D2.12.
 */
export function normalizeDescription(raw: string): string {
  return raw
    .toUpperCase()
    .replace(/[*#]/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();
}
```

**File:** `packages/core/src/utils/index.ts` — CREATE

```typescript
export { generateTxnId, resolveCollisions, buildCollisionMap } from './txn-id.js';
export { normalizeDescription } from './normalize.js';
```

**File:** `packages/core/src/parser/amex.ts` — CREATE

Per PRD Section 8.2, Amex parser. Note: Core receives data as ArrayBuffer, no file I/O.

```typescript
import * as XLSX from 'xlsx';
import Decimal from 'decimal.js';
import type { Transaction } from '../types/index.js';
import { UNCATEGORIZED_CATEGORY_ID } from '../types/index.js';
import { generateTxnId } from '../utils/txn-id.js';
import { normalizeDescription } from '../utils/normalize.js';

/**
 * Parse Amex transaction export.
 *
 * Format per PRD Section 8.2:
 * - XLSX format
 * - Skip 6 header rows
 * - Amount convention: positive = charge (money out), negative = credit/refund
 * - Has category column
 *
 * Per IK D3.1: Amex positive = charge, so signed_amount = -raw
 */
export function parseAmex(data: ArrayBuffer, accountId: number, sourceFile: string): Transaction[] {
  const workbook = XLSX.read(data, { type: 'array' });
  const sheet = workbook.Sheets[workbook.SheetNames[0]];

  // Convert to JSON, skipping first 6 rows
  const rows = XLSX.utils.sheet_to_json<Record<string, unknown>>(sheet, { range: 6 });

  if (rows.length === 0) {
    return [];
  }

  // Header validation - check first row has expected columns
  const firstRow = rows[0];
  const requiredColumns = ['Date', 'Description', 'Amount'];
  for (const col of requiredColumns) {
    if (!(col in firstRow)) {
      throw new Error(`Amex parser: Missing required column '${col}'. Found: ${Object.keys(firstRow).join(', ')}`);
    }
  }

  const transactions: Transaction[] = [];
  let skippedDates = 0;

  for (const row of rows) {
    const dateValue = row['Date'];
    if (!dateValue) continue;

    // Parse date - Amex uses Excel serial numbers or MM/DD/YYYY strings
    const txnDate = parseAmexDate(dateValue);
    if (!txnDate) {
      skippedDates++;
      continue;
    }

    const rawDesc = String(row['Description'] ?? '');
    const rawAmount = new Decimal(String(row['Amount'] ?? '0'));

    // Amex: positive = charge = money out, so negate
    const signedAmount = rawAmount.negated();

    // Format date as ISO
    const effectiveDate = formatIsoDate(txnDate);

    const txn: Transaction = {
      txn_id: generateTxnId(effectiveDate, rawDesc, signedAmount, accountId),
      txn_date: effectiveDate,
      post_date: effectiveDate, // Amex doesn't always have separate post date
      effective_date: effectiveDate,
      description: normalizeDescription(rawDesc),
      raw_description: rawDesc,
      signed_amount: signedAmount.toString(),
      account_id: accountId,
      category_id: UNCATEGORIZED_CATEGORY_ID, // Will be categorized later
      raw_category: row['Category'] ? String(row['Category']) : undefined,
      source_file: sourceFile,
      confidence: 0,
      needs_review: false,
      review_reasons: [],
    };

    transactions.push(txn);
  }

  if (skippedDates > 0) {
    // Per IK D8.7: Log warning about skipped dates
    console.warn(`Amex parser: Skipped ${skippedDates} transactions with unparseable dates`);
  }

  return transactions;
}

/**
 * Parse Amex date value (Excel serial or string).
 */
function parseAmexDate(value: unknown): Date | null {
  if (typeof value === 'number') {
    // Excel serial date
    return excelSerialToDate(value);
  }

  if (typeof value === 'string') {
    // Try MM/DD/YYYY format
    const match = value.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
    if (match) {
      const [, month, day, year] = match;
      return new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
    }

    // Try YYYY-MM-DD format
    const isoMatch = value.match(/^(\d{4})-(\d{2})-(\d{2})$/);
    if (isoMatch) {
      const [, year, month, day] = isoMatch;
      return new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
    }
  }

  return null;
}

/**
 * Convert Excel serial date to JavaScript Date.
 */
function excelSerialToDate(serial: number): Date {
  // Excel serial: days since 1899-12-30 (accounting for 1900 leap year bug)
  const utcDays = serial - 25569; // Adjust to Unix epoch
  const utcMs = utcDays * 86400 * 1000;
  return new Date(utcMs);
}

/**
 * Format date as ISO YYYY-MM-DD string.
 */
function formatIsoDate(date: Date): string {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}
```

**File:** `packages/core/src/parser/detect.ts` — CREATE

Per PRD Section 8.1, parser registry pattern. Note: This is headless - returns function reference, doesn't do I/O.

```typescript
import { parseAmex } from './amex.js';
import type { Transaction } from '../types/index.js';

/**
 * Parser function signature.
 * Takes ArrayBuffer (not file path) to keep core headless.
 */
export type ParserFn = (data: ArrayBuffer, accountId: number, sourceFile: string) => Transaction[];

/**
 * Parser registry entry.
 */
interface ParserEntry {
  /** Glob pattern to match filename */
  pattern: RegExp;
  /** Parser function */
  parser: ParserFn;
}

/**
 * Registry of parsers.
 * Per PRD Section 8.1, filename convention: {institution}_{accountID}_{YYYYMM}.{ext}
 */
const PARSERS: Record<string, ParserEntry> = {
  amex: {
    pattern: /^amex_\d{4}_\d{6}\.xlsx$/i,
    parser: parseAmex,
  },
  // Remaining parsers will be added in Phase 2:
  // chase_checking, boa_checking, boa_credit, fidelity, discover
};

/**
 * Detection result returned by detectParser.
 */
export interface ParserDetectionResult {
  parser: ParserFn;
  accountId: number;
  parserName: string;
}

/**
 * Detect parser for a given filename.
 *
 * Per PRD Section 8.1:
 * - Skip hidden files (start with .)
 * - Skip temp files (start with ~)
 * - Extract account ID from filename
 *
 * Returns null if no parser matches or file should be skipped.
 */
export function detectParser(filename: string): ParserDetectionResult | null {
  // Per IK D8.8: Skip hidden and temp files
  if (filename.startsWith('.') || filename.startsWith('~')) {
    return null;
  }

  for (const [name, { pattern, parser }] of Object.entries(PARSERS)) {
    if (pattern.test(filename)) {
      const accountId = extractAccountId(filename);
      if (accountId !== null) {
        return { parser, accountId, parserName: name };
      }
    }
  }

  return null;
}

/**
 * Extract 4-digit account ID from filename.
 * Expected format: {institution}_{accountID}_{YYYYMM}.{ext}
 */
export function extractAccountId(filename: string): number | null {
  const parts = filename.split('_');
  if (parts.length >= 2) {
    const idStr = parts[1];
    if (/^\d{4}$/.test(idStr)) {
      return parseInt(idStr, 10);
    }
  }
  return null;
}

/**
 * Get list of supported parser names.
 */
export function getSupportedParsers(): string[] {
  return Object.keys(PARSERS);
}
```

**File:** `packages/core/src/parser/index.ts` — CREATE

```typescript
export { parseAmex } from './amex.js';
export { detectParser, extractAccountId, getSupportedParsers } from './detect.js';
export type { ParserFn, ParserDetectionResult } from './detect.js';
```

**File:** `packages/core/src/index.ts` — CREATE

```typescript
// Types (re-exported from shared)
export type {
  Transaction,
  CategorizationResult,
  Rule,
  RuleSet,
  Account,
  ChartOfAccounts,
  JournalLine,
  JournalEntry,
  RunManifest,
} from './types/index.js';

export {
  TransactionSchema,
  CategorizationResultSchema,
  RuleSchema,
  RuleSetSchema,
  AccountSchema,
  ChartOfAccountsSchema,
  JournalLineSchema,
  JournalEntrySchema,
  RunManifestSchema,
  UNCATEGORIZED_CATEGORY_ID,
  CONFIDENCE,
  PATTERN_VALIDATION,
  MATCHING_CONFIG,
} from './types/index.js';

// Utils
export { generateTxnId, resolveCollisions, buildCollisionMap } from './utils/index.js';
export { normalizeDescription } from './utils/index.js';

// Parsers
export { parseAmex } from './parser/index.js';
export { detectParser, extractAccountId, getSupportedParsers } from './parser/index.js';
export type { ParserFn, ParserDetectionResult } from './parser/index.js';
```

**File:** `packages/core/tests/utils/txn-id.test.ts` — CREATE

```typescript
import { describe, it, expect } from 'vitest';
import Decimal from 'decimal.js';
import { generateTxnId, resolveCollisions, buildCollisionMap } from '../../src/utils/txn-id.js';
import type { Transaction } from '../../src/types/index.js';

describe('generateTxnId', () => {
  it('generates 16-character hex string', () => {
    const id = generateTxnId('2026-01-15', 'UBER *TRIP', new Decimal('-23.45'), 2122);
    expect(id).toHaveLength(16);
    expect(id).toMatch(/^[0-9a-f]{16}$/);
  });

  it('is deterministic - same input produces same output', () => {
    const id1 = generateTxnId('2026-01-15', 'UBER *TRIP', new Decimal('-23.45'), 2122);
    const id2 = generateTxnId('2026-01-15', 'UBER *TRIP', new Decimal('-23.45'), 2122);
    expect(id1).toBe(id2);
  });

  it('produces different IDs for different dates', () => {
    const id1 = generateTxnId('2026-01-15', 'UBER *TRIP', new Decimal('-23.45'), 2122);
    const id2 = generateTxnId('2026-01-16', 'UBER *TRIP', new Decimal('-23.45'), 2122);
    expect(id1).not.toBe(id2);
  });

  it('produces different IDs for different descriptions', () => {
    const id1 = generateTxnId('2026-01-15', 'UBER *TRIP', new Decimal('-23.45'), 2122);
    const id2 = generateTxnId('2026-01-15', 'LYFT *RIDE', new Decimal('-23.45'), 2122);
    expect(id1).not.toBe(id2);
  });

  it('produces different IDs for different amounts', () => {
    const id1 = generateTxnId('2026-01-15', 'UBER *TRIP', new Decimal('-23.45'), 2122);
    const id2 = generateTxnId('2026-01-15', 'UBER *TRIP', new Decimal('-25.00'), 2122);
    expect(id1).not.toBe(id2);
  });

  it('produces different IDs for different accounts', () => {
    const id1 = generateTxnId('2026-01-15', 'UBER *TRIP', new Decimal('-23.45'), 2122);
    const id2 = generateTxnId('2026-01-15', 'UBER *TRIP', new Decimal('-23.45'), 2120);
    expect(id1).not.toBe(id2);
  });

  it('handles negative amounts correctly', () => {
    const id = generateTxnId('2026-01-15', 'REFUND', new Decimal('50.00'), 2122);
    expect(id).toHaveLength(16);
  });

  it('handles zero amount', () => {
    const id = generateTxnId('2026-01-15', 'ZERO', new Decimal('0'), 2122);
    expect(id).toHaveLength(16);
  });

  it('normalizes trailing zeros in amount', () => {
    const id1 = generateTxnId('2026-01-15', 'TEST', new Decimal('-23.45'), 2122);
    const id2 = generateTxnId('2026-01-15', 'TEST', new Decimal('-23.450'), 2122);
    // Per IK D2.12: should normalize amount, so these should be equal
    expect(id1).toBe(id2);
  });
});

describe('resolveCollisions', () => {
  const makeTxn = (id: string): Transaction => ({
    txn_id: id,
    txn_date: '2026-01-15',
    post_date: '2026-01-15',
    effective_date: '2026-01-15',
    description: 'TEST',
    raw_description: 'TEST',
    signed_amount: '-10.00',
    account_id: 2122,
    category_id: 4999,
    source_file: 'test.xlsx',
    confidence: 0,
    needs_review: false,
    review_reasons: [],
  });

  it('leaves unique IDs unchanged', () => {
    const txns = [
      makeTxn('aaaa111111111111'),
      makeTxn('bbbb222222222222'),
      makeTxn('cccc333333333333'),
    ];

    resolveCollisions(txns);

    expect(txns[0].txn_id).toBe('aaaa111111111111');
    expect(txns[1].txn_id).toBe('bbbb222222222222');
    expect(txns[2].txn_id).toBe('cccc333333333333');
  });

  it('adds suffix to duplicate IDs', () => {
    const txns = [
      makeTxn('aaaa111111111111'),
      makeTxn('aaaa111111111111'),
      makeTxn('aaaa111111111111'),
    ];

    resolveCollisions(txns);

    expect(txns[0].txn_id).toBe('aaaa111111111111'); // First occurrence unchanged
    expect(txns[1].txn_id).toBe('aaaa111111111111-02');
    expect(txns[2].txn_id).toBe('aaaa111111111111-03');
  });

  it('handles mixed unique and duplicate IDs', () => {
    const txns = [
      makeTxn('aaaa111111111111'),
      makeTxn('bbbb222222222222'),
      makeTxn('aaaa111111111111'),
      makeTxn('cccc333333333333'),
      makeTxn('aaaa111111111111'),
    ];

    resolveCollisions(txns);

    expect(txns[0].txn_id).toBe('aaaa111111111111');
    expect(txns[1].txn_id).toBe('bbbb222222222222');
    expect(txns[2].txn_id).toBe('aaaa111111111111-02');
    expect(txns[3].txn_id).toBe('cccc333333333333');
    expect(txns[4].txn_id).toBe('aaaa111111111111-03');
  });
});

describe('buildCollisionMap', () => {
  const makeTxn = (id: string): Transaction => ({
    txn_id: id,
    txn_date: '2026-01-15',
    post_date: '2026-01-15',
    effective_date: '2026-01-15',
    description: 'TEST',
    raw_description: 'TEST',
    signed_amount: '-10.00',
    account_id: 2122,
    category_id: 4999,
    source_file: 'test.xlsx',
    confidence: 0,
    needs_review: false,
    review_reasons: [],
  });

  it('returns empty map for no collisions', () => {
    const txns = [
      makeTxn('aaaa111111111111'),
      makeTxn('bbbb222222222222'),
    ];

    const map = buildCollisionMap(txns);
    expect(map).toEqual({});
  });

  it('includes collision counts for duplicates', () => {
    const txns = [
      makeTxn('aaaa111111111111'),
      makeTxn('aaaa111111111111-02'),
      makeTxn('aaaa111111111111-03'),
      makeTxn('bbbb222222222222'),
    ];

    const map = buildCollisionMap(txns);
    expect(map).toEqual({
      'aaaa111111111111': 3,
    });
  });
});
```

**File:** `packages/core/tests/utils/normalize.test.ts` — CREATE

```typescript
import { describe, it, expect } from 'vitest';
import { normalizeDescription } from '../../src/utils/normalize.js';

describe('normalizeDescription', () => {
  it('converts to uppercase', () => {
    expect(normalizeDescription('uber trip')).toBe('UBER TRIP');
  });

  it('replaces * with space', () => {
    expect(normalizeDescription('UBER*TRIP')).toBe('UBER TRIP');
  });

  it('replaces # with space', () => {
    expect(normalizeDescription('STORE#123')).toBe('STORE 123');
  });

  it('collapses multiple spaces', () => {
    expect(normalizeDescription('UBER   TRIP')).toBe('UBER TRIP');
  });

  it('trims leading and trailing whitespace', () => {
    expect(normalizeDescription('  UBER TRIP  ')).toBe('UBER TRIP');
  });

  it('handles complex real-world descriptions', () => {
    expect(normalizeDescription('UBER *TRIP HELP.UBER.COM')).toBe('UBER TRIP HELP.UBER.COM');
    expect(normalizeDescription('AMZN*1A2B3C4D5E AMZN.COM/BILL')).toBe('AMZN 1A2B3C4D5E AMZN.COM/BILL');
  });

  it('handles empty string', () => {
    expect(normalizeDescription('')).toBe('');
  });

  it('handles string with only special characters', () => {
    expect(normalizeDescription('***###')).toBe('');
  });

  it('preserves other punctuation', () => {
    expect(normalizeDescription('HELP.UBER.COM')).toBe('HELP.UBER.COM');
    expect(normalizeDescription('AMAZON-PRIME')).toBe('AMAZON-PRIME');
  });
});
```

**File:** `packages/core/tests/parser/amex.test.ts` — CREATE

```typescript
import { describe, it, expect } from 'vitest';
import * as XLSX from 'xlsx';
import { parseAmex } from '../../src/parser/amex.js';

describe('parseAmex', () => {
  /**
   * Create mock Amex XLSX data.
   * Amex format has 6 header rows before data.
   */
  function createAmexWorkbook(rows: Record<string, unknown>[]): ArrayBuffer {
    // Create worksheet with 6 blank header rows, then header row, then data
    const headerRows = Array(6).fill(['', '', '', '', '']);
    const dataWithHeaders = [
      ['Date', 'Description', 'Amount', 'Category'],
      ...rows.map(r => [r['Date'], r['Description'], r['Amount'], r['Category']]),
    ];

    const ws = XLSX.utils.aoa_to_sheet([...headerRows, ...dataWithHeaders]);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Sheet1');

    const buffer = XLSX.write(wb, { type: 'array', bookType: 'xlsx' });
    return buffer;
  }

  it('parses valid Amex transactions', () => {
    const data = createAmexWorkbook([
      { Date: '01/15/2026', Description: 'UBER *TRIP', Amount: '23.45', Category: 'Transportation' },
      { Date: '01/16/2026', Description: 'STARBUCKS', Amount: '5.00', Category: 'Restaurant' },
    ]);

    const transactions = parseAmex(data, 2122, 'amex_2122_202601.xlsx');

    expect(transactions).toHaveLength(2);

    // First transaction
    expect(transactions[0].effective_date).toBe('2026-01-15');
    expect(transactions[0].raw_description).toBe('UBER *TRIP');
    expect(transactions[0].description).toBe('UBER TRIP'); // Normalized
    expect(transactions[0].signed_amount).toBe('-23.45'); // Negated (charge = money out)
    expect(transactions[0].account_id).toBe(2122);
    expect(transactions[0].raw_category).toBe('Transportation');
    expect(transactions[0].txn_id).toHaveLength(16);

    // Second transaction
    expect(transactions[1].effective_date).toBe('2026-01-16');
    expect(transactions[1].signed_amount).toBe('-5'); // Decimal normalizes "5.00" to "5"
  });

  it('handles negative amounts (refunds)', () => {
    const data = createAmexWorkbook([
      { Date: '01/15/2026', Description: 'REFUND', Amount: '-50.00', Category: 'Other' },
    ]);

    const transactions = parseAmex(data, 2122, 'amex_2122_202601.xlsx');

    expect(transactions).toHaveLength(1);
    expect(transactions[0].signed_amount).toBe('50'); // -(-50) = 50 (money in)
  });

  it('returns empty array for empty file', () => {
    const data = createAmexWorkbook([]);
    const transactions = parseAmex(data, 2122, 'amex_2122_202601.xlsx');
    expect(transactions).toHaveLength(0);
  });

  it('generates deterministic txn_ids', () => {
    const data = createAmexWorkbook([
      { Date: '01/15/2026', Description: 'UBER *TRIP', Amount: '23.45', Category: 'Transportation' },
    ]);

    const transactions1 = parseAmex(data, 2122, 'amex_2122_202601.xlsx');
    const transactions2 = parseAmex(data, 2122, 'amex_2122_202601.xlsx');

    expect(transactions1[0].txn_id).toBe(transactions2[0].txn_id);
  });

  it('sets default values correctly', () => {
    const data = createAmexWorkbook([
      { Date: '01/15/2026', Description: 'TEST', Amount: '10.00', Category: '' },
    ]);

    const transactions = parseAmex(data, 2122, 'amex_2122_202601.xlsx');

    expect(transactions[0].category_id).toBe(4999); // UNCATEGORIZED
    expect(transactions[0].confidence).toBe(0);
    expect(transactions[0].needs_review).toBe(false);
    expect(transactions[0].review_reasons).toEqual([]);
  });
});
```

### Task 1.3: Create @finance-engine/cli Package (Minimal PoC)

**Directory structure:**
```
packages/cli/
├── package.json
├── tsconfig.json
└── src/
    └── index.ts
```

**File:** `packages/cli/package.json` — CREATE

```json
{
  "name": "@finance-engine/cli",
  "version": "2.0.0",
  "type": "module",
  "bin": {
    "fineng": "./dist/index.js"
  },
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "test": "vitest run",
    "typecheck": "tsc --noEmit",
    "start": "node ./dist/index.js"
  },
  "dependencies": {
    "@finance-engine/core": "workspace:*",
    "@finance-engine/shared": "workspace:*"
  }
}
```

**File:** `packages/cli/tsconfig.json` — CREATE

```json
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*.ts"],
  "exclude": ["tests", "dist"],
  "references": [
    { "path": "../shared" },
    { "path": "../core" }
  ]
}
```

**File:** `packages/cli/src/index.ts` — CREATE

This is a minimal proof-of-concept showing CLI handles I/O, core is pure:

```typescript
#!/usr/bin/env node
/**
 * Finance Engine CLI - Phase 1 Proof of Concept
 *
 * This minimal CLI demonstrates the headless core architecture:
 * - CLI handles all file I/O
 * - Core receives ArrayBuffer, returns Transaction[]
 * - No file system access in core package
 *
 * Full implementation will be added in Phase 5.
 */

import { readFileSync } from 'node:fs';
import { basename } from 'node:path';
import { parseAmex, detectParser, resolveCollisions } from '@finance-engine/core';

async function main() {
  const args = process.argv.slice(2);

  if (args.length === 0) {
    console.log('Finance Engine CLI v2.0.0');
    console.log('');
    console.log('Phase 1 Proof of Concept');
    console.log('Usage: fineng <amex-file.xlsx>');
    console.log('');
    console.log('Example:');
    console.log('  fineng amex_2122_202601.xlsx');
    process.exit(0);
  }

  const filePath = args[0];
  const filename = basename(filePath);

  // Detect parser from filename
  const detection = detectParser(filename);
  if (!detection) {
    console.error(`Error: No parser found for file: ${filename}`);
    console.error('Expected format: {institution}_{accountID}_{YYYYMM}.{ext}');
    console.error('Example: amex_2122_202601.xlsx');
    process.exit(1);
  }

  console.log(`Detected parser: ${detection.parserName}`);
  console.log(`Account ID: ${detection.accountId}`);
  console.log('');

  // CLI handles file I/O - reads file to ArrayBuffer
  const fileBuffer = readFileSync(filePath);
  const arrayBuffer = fileBuffer.buffer.slice(
    fileBuffer.byteOffset,
    fileBuffer.byteOffset + fileBuffer.byteLength
  );

  // Core receives ArrayBuffer, returns Transaction[] (no I/O in core)
  const transactions = detection.parser(arrayBuffer, detection.accountId, filename);

  // Handle collisions
  resolveCollisions(transactions);

  console.log(`Parsed ${transactions.length} transactions:`);
  console.log('');

  for (const txn of transactions) {
    console.log(`${txn.effective_date} | ${txn.signed_amount.padStart(10)} | ${txn.description.slice(0, 40)}`);
  }

  console.log('');
  console.log('Phase 1 PoC complete - headless core architecture verified.');
}

main().catch((err) => {
  console.error('Error:', err.message);
  process.exit(1);
});
```

### Task 1.4: Create @finance-engine/web Package (Scaffold Only)

**Directory structure:**
```
packages/web/
├── package.json
├── tsconfig.json
├── src/
│   └── index.ts
└── README.md
```

**File:** `packages/web/package.json` — CREATE

```json
{
  "name": "@finance-engine/web",
  "version": "2.0.0",
  "type": "module",
  "private": true,
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "test": "vitest run",
    "typecheck": "tsc --noEmit"
  },
  "dependencies": {
    "@finance-engine/core": "workspace:*",
    "@finance-engine/shared": "workspace:*"
  }
}
```

**File:** `packages/web/tsconfig.json` — CREATE

```json
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*.ts"],
  "exclude": ["dist"],
  "references": [
    { "path": "../shared" },
    { "path": "../core" }
  ]
}
```

**File:** `packages/web/src/index.ts` — CREATE

```typescript
/**
 * @finance-engine/web
 *
 * Browser/PWA frontend for Finance Engine.
 * OUT OF SCOPE for initial release.
 *
 * This package will provide:
 * - File upload interface
 * - Transaction review UI
 * - Category management
 * - Report generation
 *
 * The core package is designed to run in browser without modification.
 */

export const VERSION = '2.0.0';
export const STATUS = 'scaffold';
```

**File:** `packages/web/README.md` — CREATE

```markdown
# @finance-engine/web

Browser/PWA frontend for Finance Engine.

## Status

**OUT OF SCOPE** for initial v2.0 release.

This package is scaffolded for future implementation. The `@finance-engine/core` package is designed to run in browser without modification.

## Planned Features

- File upload interface (drag & drop)
- Transaction review UI
- Category management
- Report generation and visualization
- IndexedDB for local storage
- Optional sync to cloud folders

## Architecture

The web package will:
1. Use File API to read uploaded bank exports
2. Pass ArrayBuffer to core parsers (same as CLI)
3. Display transactions for review
4. Export results as Excel downloads

All processing happens client-side. No transaction data leaves the browser.
```

---

## Verification Steps

### After All Tasks Complete

**1. Install dependencies:**
```bash
cd /Users/jonathanoh/Dev/finance-engine-2.0
pnpm install
```

**2. Build all packages:**
```bash
pnpm build
```

**3. Run all tests:**
```bash
pnpm test
```

**4. Verify architecture constraint (no fs in core):**
```bash
# Should return no results - core has no file system imports
grep -r "from 'node:fs'" packages/core/src/ || echo "✓ No fs imports in core"
grep -r "from 'fs'" packages/core/src/ || echo "✓ No fs imports in core"
grep -r "require('fs')" packages/core/src/ || echo "✓ No require(fs) in core"
```

**5. Test CLI proof-of-concept (requires sample file):**
```bash
# Create minimal test fixture
mkdir -p fixtures
# (Create sample amex file manually or use existing)
# pnpm --filter @finance-engine/cli start fixtures/amex_2122_202601.xlsx
```

---

## Commit History

After completing all tasks, the commit history should look like:

```
feat(infra): add monorepo configuration and build tooling
feat(shared): add Zod schemas and type definitions
feat(core): add txn-id generation and collision handling
feat(core): add description normalization
feat(core): add Amex parser with detection
feat(cli): add minimal proof-of-concept CLI
feat(web): add scaffold package
test: add comprehensive test suites for Phase 1 components
```

**Final commit message for PR:**
```
feat(phase-1): foundation scaffold with proof of architecture

Establishes the Finance Engine v2.0 monorepo with:
- pnpm workspace configuration
- TypeScript project references
- Vitest test infrastructure
- @finance-engine/shared: Zod schemas for all data types
- @finance-engine/core: generateTxnId, resolveCollisions, normalizeDescription, parseAmex
- @finance-engine/cli: minimal PoC demonstrating headless core
- @finance-engine/web: scaffold for future implementation

Architecture verified:
- Core package has zero I/O imports
- CLI handles file reading, core receives ArrayBuffer
- All monetary values use decimal.js (stored as strings in schemas)

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
```

---

## PR Template

**Title:** `feat(phase-1): Foundation scaffold with proof of architecture`

**Body:**
```markdown
## Summary

Phase 1 of Finance Engine v2.0 TypeScript rewrite. Establishes complete monorepo infrastructure and proves the headless core architecture with a working Amex parser.

## Changes

- Monorepo setup with pnpm workspaces
- TypeScript project references for incremental builds
- Vitest for testing
- `@finance-engine/shared`: Zod schemas matching PRD v2.2 specifications
- `@finance-engine/core`: Transaction ID generation, collision handling, description normalization, Amex parser
- `@finance-engine/cli`: Minimal PoC demonstrating headless core pattern
- `@finance-engine/web`: Scaffold (out of scope for v2.0)

## Architecture Verification

- [x] Core package has no `node:fs` imports
- [x] CLI handles all file I/O
- [x] Monetary values use decimal.js
- [x] Zod schemas match PRD Section 7

## Test Plan

- [x] `pnpm build` succeeds for all packages
- [x] `pnpm test` passes all tests
- [x] CLI PoC parses sample Amex file
- [x] Architecture constraint grep returns no violations

---

Generated with [Claude Code](https://claude.com/claude-code)
```

---

## Critical Files Summary

| Package | File | Purpose |
|---------|------|---------|
| shared | `src/schemas.ts` | All Zod schemas - source of truth for types |
| shared | `src/constants.ts` | Confidence scores, validation thresholds |
| core | `src/utils/txn-id.ts` | Transaction ID generation and collision handling |
| core | `src/utils/normalize.ts` | Description normalization for matching |
| core | `src/parser/amex.ts` | Amex parser implementation |
| core | `src/parser/detect.ts` | Parser detection from filename |
| cli | `src/index.ts` | Proof-of-concept CLI |
